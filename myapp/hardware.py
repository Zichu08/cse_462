# myapp/hardware.py
from pynq import DefaultIP, Overlay, allocate

class AddDriver(DefaultIP):
    def __init__(self, description):
        super().__init__(description=description)
    bindto = ['xilinx.com:hls:add:1.0']
    def add(self, a, b):
        self.write(0x10, a)
        self.write(0x18, b)
        return self.read(0x20)

# --- New Convolution Accelerator Driver ---
class Conv2DDriver(DefaultIP):
    def __init__(self, description):
        super().__init__(description=description)
    # This “bindto” string should match the metadata generated by your HLS tool.
    bindto = ['xilinx.com:hls:conv2d:1.0']

    def conv2d(self, image, kernel):
        """
        Perform a convolution on a grayscale image using the hardware accelerator.
        :param image: 2D NumPy array (grayscale image, e.g. np.uint8)
        :param kernel: 2D NumPy array (for example, an edge-detection kernel)
        :return: convolved image as a NumPy array (same shape as input)
        """
        # Get dimensions
        height, width = image.shape
        k_height, k_width = kernel.shape

        # Allocate DMA-accessible buffers for input and output.
        input_buffer = allocate(shape=image.shape, dtype=image.dtype)
        output_buffer = allocate(shape=image.shape, dtype=image.dtype)

        # Copy image data into the input buffer.
        input_buffer[:] = image[:]
        
        # Write configuration registers.
        # (The register offsets here are placeholders. The accelerator’s design
        # determines the actual addresses and data format.)
        self.write(0x10, width)         # Image width
        self.write(0x14, height)        # Image height
        self.write(0x18, k_width)       # Kernel width
        self.write(0x1C, k_height)      # Kernel height

        # Write the physical addresses of the DMA buffers.
        self.write(0x20, input_buffer.physical_address)
        self.write(0x28, output_buffer.physical_address)

        # Start the accelerator by writing a start command.
        self.write(0x00, 0x01)

        # Poll for completion. (A real design might use interrupts.)
        while (self.read(0x00) & 0x2) == 0:
            pass

        # Copy the output data back to a NumPy array.
        result = output_buffer.copy()

        # Free the allocated buffers.
        input_buffer.freebuffer()
        output_buffer.freebuffer()

        return result


# --- Load Overlays and Expose Driver Instances ---

# Load the overlay for the addition accelerator.
adder_overlay = Overlay('/home/xilinx/pynq/overlays/adder/adder.bit')
scalar_add = adder_overlay.scalar_add

# Load the overlay for the convolution accelerator.
# conv2d_overlay = Overlay('/home/xilinx/pynq/overlays/conv2d/conv2d.bit')
# conv2d_driver = conv2d_overlay.conv2d_driver
